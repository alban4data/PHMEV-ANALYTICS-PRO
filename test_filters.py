#!/usr/bin/env python3
"""
Script de test automatis√© pour v√©rifier tous les filtres de l'application PHMEV
Teste le chargement, la coh√©rence et le fonctionnement de tous les filtres
"""

import sys
import os
import traceback
from datetime import datetime
import pandas as pd

# Ajouter le r√©pertoire courant au path pour importer les modules
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

def test_imports():
    """Test 1: V√©rifier que tous les imports fonctionnent"""
    print("üß™ Test 1: Imports des modules...")
    try:
        # Test des imports principaux
        import streamlit as st
        import pandas as pd
        import numpy as np
        from google.cloud import bigquery
        from google.oauth2 import service_account
        
        # Test de l'import du cache int√©gr√©
        from filter_cache_embedded import get_embedded_cache
        
        print("‚úÖ Tous les imports r√©ussis")
        return True
    except Exception as e:
        print(f"‚ùå Erreur d'import: {e}")
        return False

def test_embedded_cache():
    """Test 2: V√©rifier le cache int√©gr√©"""
    print("\nüß™ Test 2: Cache int√©gr√©...")
    try:
        from filter_cache_embedded import get_embedded_cache
        cache = get_embedded_cache()
        
        # V√©rifier la structure du cache
        required_keys = ['atc1', 'atc2', 'atc3', 'atc4', 'atc5', 'villes', 'categories', 'etablissements', 'medicaments']
        
        for key in required_keys:
            if key not in cache:
                print(f"‚ùå Cl√© manquante dans le cache: {key}")
                return False
            
            if not isinstance(cache[key], list):
                print(f"‚ùå Type incorrect pour {key}: {type(cache[key])}")
                return False
            
            if len(cache[key]) == 0:
                print(f"‚ö†Ô∏è  Liste vide pour {key}")
            else:
                print(f"‚úÖ {key}: {len(cache[key])} √©l√©ments")
        
        # V√©rifier la structure des ATC (tuples code, label)
        for atc_level in ['atc1', 'atc2', 'atc3', 'atc4', 'atc5']:
            if cache[atc_level] and len(cache[atc_level]) > 0:
                first_item = cache[atc_level][0]
                if not isinstance(first_item, tuple) or len(first_item) != 2:
                    print(f"‚ùå Structure incorrecte pour {atc_level}: {first_item}")
                    return False
        
        print("‚úÖ Cache int√©gr√© valide")
        return True
    except Exception as e:
        print(f"‚ùå Erreur cache int√©gr√©: {e}")
        traceback.print_exc()
        return False

def test_bigquery_connection():
    """Test 3: V√©rifier la connexion BigQuery"""
    print("\nüß™ Test 3: Connexion BigQuery...")
    try:
        # Simuler l'import des fonctions de l'app
        sys.path.insert(0, '.')
        
        # Test de connexion avec fichier local
        import os
        from google.oauth2 import service_account
        from google.cloud import bigquery
        
        json_file = 'test-db-473321-aed58eeb55a8.json'
        if os.path.exists(json_file):
            try:
                credentials = service_account.Credentials.from_service_account_file(json_file)
                client = bigquery.Client(credentials=credentials, project='test-db-473321')
                
                # Test simple de requ√™te
                test_query = "SELECT 1 as test"
                result = client.query(test_query).result()
                
                print("‚úÖ Connexion BigQuery r√©ussie")
                return True, client
            except Exception as e:
                print(f"‚ö†Ô∏è  Connexion BigQuery √©chou√©e: {e}")
                return False, None
        else:
            print("‚ö†Ô∏è  Fichier de credentials non trouv√©")
            return False, None
    except Exception as e:
        print(f"‚ùå Erreur test BigQuery: {e}")
        return False, None

def test_filter_functions():
    """Test 4: Tester les fonctions de filtrage"""
    print("\nüß™ Test 4: Fonctions de filtrage...")
    try:
        # Cr√©er un environnement de test minimal
        class MockStreamlit:
            def cache_data(self, ttl=None):
                def decorator(func):
                    return func
                return decorator
            
            def cache_resource(self):
                def decorator(func):
                    return func
                return decorator
        
        # Mock streamlit
        import sys
        sys.modules['streamlit'] = MockStreamlit()
        
        # Maintenant importer et tester les fonctions
        from streamlit_app import get_base_filter_options
        
        print("üîÑ Test du chargement des options de base...")
        options = get_base_filter_options()
        
        if not options:
            print("‚ùå Options vides")
            return False
        
        # V√©rifier les cl√©s essentielles
        essential_keys = ['atc1', 'medicaments', 'etablissements', 'villes']
        for key in essential_keys:
            if key not in options:
                print(f"‚ùå Cl√© manquante: {key}")
                return False
            print(f"‚úÖ {key}: {len(options[key])} √©l√©ments")
        
        print("‚úÖ Fonctions de filtrage OK")
        return True
    except Exception as e:
        print(f"‚ùå Erreur fonctions de filtrage: {e}")
        traceback.print_exc()
        return False

def test_search_functionality():
    """Test 5: Tester la fonctionnalit√© de recherche"""
    print("\nüß™ Test 5: Fonctionnalit√© de recherche...")
    try:
        from filter_cache_embedded import get_embedded_cache
        cache = get_embedded_cache()
        
        # Test de recherche de m√©dicaments
        medicaments = cache.get('medicaments', [])
        
        # Test de recherche case-insensitive
        search_term = "cabozantinib"
        matches = [med for med in medicaments if search_term.lower() in med.lower()]
        
        if matches:
            print(f"‚úÖ Recherche '{search_term}' trouv√©e: {len(matches)} r√©sultats")
            print(f"   Exemple: {matches[0]}")
        else:
            print(f"‚ö†Ô∏è  Recherche '{search_term}' non trouv√©e")
        
        # Test de recherche d'√©tablissements
        etablissements = cache.get('etablissements', [])
        search_etab = "chu"
        etab_matches = [etab for etab in etablissements if search_etab.lower() in etab.lower()]
        
        if etab_matches:
            print(f"‚úÖ Recherche √©tablissement '{search_etab}' trouv√©e: {len(etab_matches)} r√©sultats")
        else:
            print(f"‚ö†Ô∏è  Recherche √©tablissement '{search_etab}' non trouv√©e")
        
        # Test du mapping des m√©dicaments
        drug_mapping = {
            'cabometyx': 'cabozantinib',
            'keytruda': 'pembrolizumab',
            'opdivo': 'nivolumab'
        }
        
        for commercial, molecular in drug_mapping.items():
            molecular_matches = [med for med in medicaments if molecular.lower() in med.lower()]
            if molecular_matches:
                print(f"‚úÖ Mapping {commercial} -> {molecular}: {len(molecular_matches)} r√©sultats")
            else:
                print(f"‚ö†Ô∏è  Mapping {commercial} -> {molecular}: non trouv√©")
        
        print("‚úÖ Fonctionnalit√© de recherche OK")
        return True
    except Exception as e:
        print(f"‚ùå Erreur recherche: {e}")
        traceback.print_exc()
        return False

def test_hierarchical_filters():
    """Test 6: Tester les filtres hi√©rarchiques"""
    print("\nüß™ Test 6: Filtres hi√©rarchiques ATC...")
    try:
        from filter_cache_embedded import get_embedded_cache
        cache = get_embedded_cache()
        
        # V√©rifier la hi√©rarchie ATC
        atc_levels = ['atc1', 'atc2', 'atc3', 'atc4', 'atc5']
        
        for level in atc_levels:
            atc_data = cache.get(level, [])
            if not atc_data:
                print(f"‚ö†Ô∏è  Niveau {level} vide")
                continue
            
            # V√©rifier la structure (code, label)
            sample = atc_data[0]
            if isinstance(sample, tuple) and len(sample) == 2:
                code, label = sample
                print(f"‚úÖ {level}: {len(atc_data)} codes (ex: {code} - {label[:50]}...)")
            else:
                print(f"‚ùå Structure incorrecte pour {level}: {sample}")
                return False
        
        # Test de coh√©rence hi√©rarchique
        atc1_codes = [code for code, _ in cache.get('atc1', [])]
        atc2_codes = [code for code, _ in cache.get('atc2', [])]
        
        if atc1_codes and atc2_codes:
            # V√©rifier que les codes ATC2 commencent par des codes ATC1
            valid_atc2 = 0
            for atc2_code, _ in cache.get('atc2', [])[:10]:  # Test sur 10 premiers
                if any(atc2_code.startswith(atc1_code) for atc1_code, _ in cache.get('atc1', [])):
                    valid_atc2 += 1
            
            if valid_atc2 > 0:
                print(f"‚úÖ Coh√©rence hi√©rarchique ATC1->ATC2: {valid_atc2}/10 codes valides")
            else:
                print("‚ö†Ô∏è  Probl√®me de coh√©rence hi√©rarchique ATC")
        
        print("‚úÖ Filtres hi√©rarchiques OK")
        return True
    except Exception as e:
        print(f"‚ùå Erreur filtres hi√©rarchiques: {e}")
        traceback.print_exc()
        return False

def test_data_consistency():
    """Test 7: V√©rifier la coh√©rence des donn√©es"""
    print("\nüß™ Test 7: Coh√©rence des donn√©es...")
    try:
        from filter_cache_embedded import get_embedded_cache
        cache = get_embedded_cache()
        
        # V√©rifier qu'il n'y a pas de doublons
        for key, data in cache.items():
            if isinstance(data, list):
                original_len = len(data)
                unique_len = len(set(data) if all(isinstance(x, str) for x in data) else data)
                
                if key.startswith('atc'):
                    # Pour les ATC, v√©rifier les doublons sur les codes
                    codes = [item[0] if isinstance(item, tuple) else item for item in data]
                    unique_codes = len(set(codes))
                    if unique_codes != len(codes):
                        print(f"‚ö†Ô∏è  Doublons d√©tect√©s dans {key}: {len(codes)} -> {unique_codes}")
                    else:
                        print(f"‚úÖ {key}: Pas de doublons ({len(codes)} codes)")
                else:
                    if original_len != unique_len:
                        print(f"‚ö†Ô∏è  Doublons d√©tect√©s dans {key}: {original_len} -> {unique_len}")
                    else:
                        print(f"‚úÖ {key}: Pas de doublons ({original_len} √©l√©ments)")
        
        # V√©rifier les valeurs nulles ou vides
        for key, data in cache.items():
            if isinstance(data, list):
                empty_values = 0
                for item in data:
                    if isinstance(item, tuple):
                        if not item[0] or not item[1] or item[0].strip() == '' or item[1].strip() == '':
                            empty_values += 1
                    elif isinstance(item, str):
                        if not item or item.strip() == '':
                            empty_values += 1
                
                if empty_values > 0:
                    print(f"‚ö†Ô∏è  Valeurs vides dans {key}: {empty_values}")
                else:
                    print(f"‚úÖ {key}: Pas de valeurs vides")
        
        print("‚úÖ Coh√©rence des donn√©es OK")
        return True
    except Exception as e:
        print(f"‚ùå Erreur coh√©rence: {e}")
        traceback.print_exc()
        return False

def run_all_tests():
    """Ex√©cuter tous les tests"""
    print("üöÄ D√âBUT DES TESTS AUTOMATIS√âS - FILTRES PHMEV")
    print("=" * 60)
    print(f"üìÖ Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 60)
    
    tests = [
        ("Imports", test_imports),
        ("Cache int√©gr√©", test_embedded_cache),
        ("Connexion BigQuery", lambda: test_bigquery_connection()[0]),
        ("Fonctions de filtrage", test_filter_functions),
        ("Recherche", test_search_functionality),
        ("Filtres hi√©rarchiques", test_hierarchical_filters),
        ("Coh√©rence des donn√©es", test_data_consistency)
    ]
    
    results = []
    
    for test_name, test_func in tests:
        try:
            result = test_func()
            results.append((test_name, result))
        except Exception as e:
            print(f"‚ùå ERREUR CRITIQUE dans {test_name}: {e}")
            traceback.print_exc()
            results.append((test_name, False))
    
    # R√©sum√© des r√©sultats
    print("\n" + "=" * 60)
    print("üìä R√âSUM√â DES TESTS")
    print("=" * 60)
    
    passed = 0
    failed = 0
    
    for test_name, result in results:
        status = "‚úÖ PASS√â" if result else "‚ùå √âCHOU√â"
        print(f"{test_name:.<30} {status}")
        if result:
            passed += 1
        else:
            failed += 1
    
    print("-" * 60)
    print(f"Total: {len(results)} tests | R√©ussis: {passed} | √âchou√©s: {failed}")
    
    if failed == 0:
        print("üéâ TOUS LES TESTS SONT PASS√âS ! L'application est pr√™te.")
    else:
        print(f"‚ö†Ô∏è  {failed} test(s) √©chou√©(s). V√©rification n√©cessaire.")
    
    print("=" * 60)
    return failed == 0

if __name__ == "__main__":
    success = run_all_tests()
    sys.exit(0 if success else 1)
